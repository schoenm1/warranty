\newpage
\section{Aufbau der App}

%--------------------------------------------------------------------------------------------
\subsection{Klassendiagramm} \index{Klassendiagramm}

\begin{figure}[h!]
\label{fig:class_diagramm_activity}
\centering
\includegraphics[width=\textwidth]{class_diagramm_activity.png} 
\caption{Klassendiagramm Activity}
\end{figure}



\textcolor{red}{!!!! HIER KOMMEN NOCH MEHR DIAGRAMME !!!!} \\ \\ \\ \\

\textcolor{red}{!!!! KOMMT HIER NOCH TEXT? !!!!}





%--------------------------------------------------------------------------------------------
\subsection{Activities} \index{Activities}
Die Warranty App besteht aus drei verschiedenen Activities mit unterschiedlichen Aufgaben.
\\
Die \textit{CardListActivity} ist die eigentliche Haupt- Activity und dient als Einstieg in die App. Diese Activity stellt je eine Funktion zur Bearbeitung bereits existierender Quittungen sowie eine Funktion zur Erstellung eines neuen Eintrags bereit.
\\
Beim Auswählen der Bearbeitungs- Funktion wird der Benutzer in die \textit{CardActivity} geleitet, die es ihm ermöglicht sämtliche Details eines Eintrages zu bearbeiten. Mit der Speichern- Funktion wird der Eintrag in der Datenbank aktualisiert und der Benutzer zurück zur \textit{CardListActivity} geleitet.
\\
Die aufgenommen Bilder werden von der \textit{CardActivity} aus mithilfe der von Android bereitgestellten Gallery App dargestellt.
\\
Durch die Auswahl der Erstellungs- Funktion gelangt der Benutzer direkt die \textit{PhotoActivity}, die nebst weitern Funktionen die von Android bereitgestellte Kameraapplikation aufruft. Nach der Aufnahme eines Fotos wird ohne User- Interaktion in die oben erwähnte \textit{CardActivity} gewechselt.
\\

\textbf{bildli flowchart shizzle}

\subsection{Layouts} \index{Layouts}
\subsection{Menus} \index{Menus}


\subsection{Manifest.xml} \index{Manifest.xml}
\subsubsection{Permissions} \index{Permissions}
Die Warranty App benötigt wenige zusätzliche Rechte. Um Bilder speichern zu können ist jedoch ein Speicherplatz erforderlich. Da die meisten Android basierten Smartphones einen sehr kleinen internen Speicher haben, bietet sich der externe Speicher bestens an. Je nach Modell ist dies entweder eine zusätzlichen MicroSD [Glossar] Karte oder einfach eine zusätzliche logische Partition auf dem internen Speicher. Der Vorteil dieses externen Speichers ist, dass man ihn ohne weiteres auf dem Computer einhängen und auf die Dateien zugreifen kann.

Um auf diesen externen Speicher zuzugreifen, wird folgende Zeile im Manifest.xml benötigt.
\lstset{language=Java, numbers=left}


\begin{lstlisting}[label=lst:latex.listing,captionpos=b, caption={Android permission für Zugriff auf externen Storage, Manifest.xml}]
<uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />
\end{lstlisting}

Nebst dem Zugriff auf den Speicher, bedient sich Warranty den Kamerafunktionalitäten. Da diese ebenfalls explizit erlaubt werden müssen, wird das entsprechende Recht im Manifest.xml hinterlegt.
\lstset{language=xml, numbers=left}
\begin{lstlisting}[label=lst:latex.listing,captionpos=b, caption={Android permission für Kamera, Manifest.xml}]
<uses-permission android:name="android.permission.CAMERA" />
\end{lstlisting}


%--------------------------------------------------------------------------------------------
\newpage
\subsubsection{Application}
Zusätzlich werden in der Manifest.xml sämtliche Activities hinterlegt, die von der App ausgeführt werden müssen. Das diese Liste vollständig und korrekt ist, ist für die App überlebensnotwendig. Wird im Code eine App Activity aufgerufen, die in dieser Sektion nicht aufgeführt ist, stürzt die gesammte App ab.

\lstset{language=xml, numbers=left}
\begin{lstlisting}[label=lst:latex.listing,captionpos=b, caption={Deklaration der Activities, Manifest.xml}]
   <application
        android:icon="@drawable/icon"
        android:label="@string/app_name" >
        <activity
            android:name="ch.zhaw.warranty.CardListActivity"
            android:label="@string/app_name" >
            ...
        </activity>
        <activity android:name="ch.zhaw.warranty.CardActivity" />
        <activity android:name="ch.zhaw.warranty.photo.PhotoActivity" />
        <activity android:name="ch.zhaw.warranty.photo.PhotoDisplayActivity"/>
    </application>
\end{lstlisting}

Nebst den zu erlaubenden Activities wird zusätzlich die zu startende Activity, in Programmierjargon ``Main'' definiert.
\lstset{language=xml, numbers=left}
\begin{lstlisting}[label=lst:latex.listing,captionpos=b, caption={Deklaration der Main- Methode, Manifest.xml}]
        <activity
            android:name="ch.zhaw.warranty.CardListActivity"
            android:label="@string/app_name" >
            <intent-filter>
                <action android:name="android.intent.action.MAIN" />	
                <category android:name="android.intent.category.LAUNCHER" />
            </intent-filter>
\end{lstlisting}

\subsection{Ansteuerung der Kamera}
\subsection{Datenbank} \index{Datenbank} \index{DBMS}
Auch wenn wir auf unserem Smartphone eine Datenbank benötigen, so scheint die Idee, ein vollumfängliches \abkDef{DBMS}{\textbf{D}atabase \textbf{M}anagement \textbf{S}ystem}  wie beispielsweise MySQL\footnote{offizielle Website: \url{http://www.mysql.com}}\index{MySQL} oder PostgreSQL\footnote{offizielle Website: \url{http://www.postgresql.org}}\index{PostgreSQL} zu installieren absurd. Zum einen benötigen wir Features wie ein Client/Server Model, Partitioning oder ein ausgefeiltes Zugriffsberechtigungssystem nicht, zum anderen steht die dazu benötigte Performance auf einem Smartphone schlicht und einfach nicht zur Verfügung. 
\newline
Um dennoch eine Datenbank auf einem Smartphone verwenden zu können, bietet sich SQLite\footnote{offizielle Website: \url{http://www.sqlite.org}}\index{SQLite} an. SQLite ist eine Programmbibliothek, die sich direkt in der Applikation einbinden lässt und somit keinen Server- Prozess benötigt, also ressourcensparend ist. Die gesamte Datenbank inklusive aller Tabellen, Indizes und Werten werden in einer einzigen Datei abgelegt, was ein paralleles Schreiben auf die Datenbank unmöglich macht.
\newline
Dank der nativen SQLite Unterstützung von Android, fällt ein aufwändiges einbinden einer 3rd Party Library weg.
\\
Um die Datenbankfunktionalität bereitzustellen, wurde ein eigenes Java- Package \textit{ch.zhaw.warranty.database} erstellt. Die darin enthaltenen Klassen sind für das Erstellen der Datenbank und deren Tabellen (\textit{TBLWarrantyHelper}) beziehungsweise zur Bereitstellung der Datenbankfunktionen für den User (\textit{TBLWarrantyConnector}) zuständig.
\subsubsection{Definition der Tabelle}
Um aus sämtlichen Java- Klassen auf den Tabellen- sowie die Attributsnamen zugreifen zu können und um ein statisches Referenzieren in den Java- Klassen zu vermeiden, macht es Sinn, diese als statische Strings zu definieren.
\lstset{language=Java, numbers=left}
\begin{lstlisting}[label=lst:tbl_attr_names, captionpos=b, caption={Deklaration des Tabellen- sowie der Attributsnamen, TBLWarrantyHelper.java}]
public static final String TBL_NAME="warranty";
public static final String CLMN_ID = "_id";
public static final String CLMN_TITLE = "title";
public static final String CLMN_DESC = "description";
public static final String CLMN_IMGPATH = "img_path";
public static final String CLMN_CREATEDAT = "created_at";
public static final String CLMN_VLDTIL = "valid_until";
public static final String CLMN_PRICE = "price";
public static final String CLMN_RESSELLER = "reseller";
\end{lstlisting}

Darauffolgend wird das SQL- Statement zur Erstellung der Tabelle definiert. Die im Listing \refTC{lst:tbl_attr_names} aufgeführten Strings können hier bereits als Referenz benutzt werden.
\lstset{language=Java, numbers=left}
\begin{lstlisting}[label=lst:latex.listing,captionpos=b, caption={Vorbereiten Erstellungsbefehls, TBLWarrantyHelper.java}]
private static final String DB_CREATE="create table " + TBL_NAME + " (" +
	CLMN_ID + " integer primary key autoincrement," + 
	CLMN_TITLE + " text," + 
	CLMN_DESC + " text," + 
	CLMN_IMGPATH + " text," + 
	CLMN_CREATEDAT + " text," +
	CLMN_VLDTIL + " text," +
	CLMN_PRICE + " real," +
	CLMN_RESSELLER + " text);";
\end{lstlisting}

Abschliessend wird die \textit{onCreate}- Methode der Klasse \textit{Activity} überschrieben, sodass bei jedem erstellen  der Activity das Tabellen- Erstelungsstatement aufgerufen wird. Existiert die Tabelle bereits, so hat das Statement keinen Einfluss, es wird von SQLite ignoriert.
\lstset{language=Java, numbers=left}
\begin{lstlisting}[label=lst:latex.listing,captionpos=b, caption={Tabelle erstellen, TBLWarrantyHelper.java}]
@Override
public void onCreate(SQLiteDatabase db) {
	db.execSQL(DB_CREATE);
}
\end{lstlisting}

\subsubsection{Insert und Update Funktion} \label{sec:04-insert_and_update}
Die aus Anwendersicht vermutlich wichtigsten Methoden sind die Insert- und die Update- Methoden. Da diese von der Funktionalität sehr ähnlich sind, ist aus Sicht des Programmierers sinnvoll, diese zusammen zulegen. Der grundlegende Unterschied ist , dass beim Insert ein neuer Eintrag erstellt, beim Update ein bereits vorhandener Eintrag angepasst wird.

Im Javacode ist die Differenzierung denkbar einfach.
\lstset{language=Java, numbers=left}
\begin{lstlisting}[label=lst:latex.listing,captionpos=b, caption={Insert und Update Funktion, TBLWarrantyConnector.java}]
public void insertWarrantyCard(WarrantyCard card){
	...
	openDB();
		if (card.get_id() == 0) {
			db.insert(TBLWarrantyHelper.TBL_NAME, null, values);
		} else {
			db.update(TBLWarrantyHelper.TBL_NAME, values, TBLWarrantyHelper.CLMN_ID + "=" + card.get_id(), null);
		}
	closeDB();
}
\end{lstlisting}
Der Grund für diese einfache Unterscheidung liegt in der Auflistung der Quittungen im Homescreen der App. Diese sogenannte Listview \textbf{referenz zum bild} kennt von jeder aufgelisteten Quittung ihre dazugehörige ID. Möchte der User eine Quittung bearbeiten, wird in der App intern diese Referenz auf die Quittung weitergegeben. Möchte der User eine neue Quittung hinterlegen, wird das ID Feld nicht gefüllt. Dies führt dazu, dass der Standard Integer- Wert, in Java eine 0\footnote{gemäss \url{http://docs.oracle.com/javase/tutorial/java/nutsandbolts/datatypes.html}} 

\subsubsection{Delete Funktion}
Da die Quittungen nach deren Ablauf nicht automatisch gelöscht werden, kann es durchaus sein, dass ein User die Quittungen manuell löschen möchte. 

Wie bereits im Kapitel \refTC{sec:04-insert_and_update} erwähnt, ist der Listview auf dem Homescreen die ID jeder aufgelisteten Quittung bekannt. Somit kann eine Quittung direkt aus der Listview mit dem Methodenaufruf deleteCard und der dazugehörigen ID, die anschliessend das entsprechende SQL- Statement an die Datenbank kommuniziert, gelöscht werden.

Wie bereits beim Insert und Update haben wir uns auch hier die Tatsache, dass das \textbf{auto increment} von SQLite bei 1 beginnt\footnote{gemäss \url{http://www.sqlite.org/autoinc.html}} zu nutzen gemacht. Wird 0 als ID übergeben, hat dies zur Folge, dass ausnahmslos alle gespeicherten Quittungen gelöscht werden.

\lstset{language=Java, numbers=left}
\begin{lstlisting}[label=lst:latex.listing,captionpos=b, caption={Delete Funktion, TBLWarrantyConnector.java}]
public void deleteCard(int cardID) {
	openDB();
	if (cardID == 0) {
		db.delete(TBLWarrantyHelper.TBL_NAME, null, null);		
	} else {
		db.delete(TBLWarrantyHelper.TBL_NAME, TBLWarrantyHelper.CLMN_ID + "=" + cardID, null);
	}
	closeDB();
}
\end{lstlisting}

Eine Funktion zum löschen aller Quittungen wurde im Menü des Homescreens untergebracht.
